软件测试领域，特别是在 TDD 方法论中，模拟对象起着至关重要的作用。它旨在通过实现相同的接口来模仿真实对象的行为，从而在测试中模拟实际对象。然而，模拟对象的强大之处在于它的灵活性；开发人员可以在运行时指定其行为，包括调用哪些方法、 调用顺序、频率、参数规范和返回值。这种控制级别将模拟对象变成用于测试代码内交互和集成的强大工具。

模拟解决了测试复杂或互连系统时面临的一些挑战。在开发原型或测试时，由于外部依赖性、执行时间或与实际操作相关的成本等限制，仅依赖真实对象可能不可行或不切实际。

这种情况下，模拟提供了一种轻量级、可控的替代方案，可以复制必要的交互，而无需实际实现的开销或副作用。可使开发人员能够专注于组件的行为和集成，而不是其底层实现，从而促进更有针对性和更高效的测试。

区分伪对象和模拟对象对于理解用例至关重要。虽然两者都是测试中真实对象的替代品，但其具有不同的特征和用途：

\begin{itemize}
\item
伪对象：这些是模仿真实对象的简化实现，但通常为了提高测试效率而走捷径。一个例子是内存数据库，可以复制真实数据库系统的功能，而无需持久存储。伪造对象对于不审查真实对象确切工作原理的测试很实用。

\item
模拟对象：与伪造对象不同，模拟对象是预先编程的，具有特定的期望，这些期望形成了如何使用的契约。其是测试测系统与其依赖项之间交互的理想选择。例如，在测试依赖于服务的类时，可以使用该服务的模拟来确保该类按预期与服务交互，而无需实际调用服务的实际实现。
\end{itemize}

gMock 是 Google 在 C++ 中创建模拟类的框架，提供了类似于 jMock 和 EasyMock 为 Java 提供的全面解决方案。使用 gMock，开发人员首先使用宏描述要模拟的对象的接口，然后生成模拟类实现。然后，开发人员可以实例化模拟对象，使用 gMock 的直观语法设置其预期行为和交互。测试执行期间， gMock 会监控这些模拟对象，确保所有指定的交互都符合定义的期望，并将偏差标记为错误。这种即时反馈对于识别组件与其依赖项交互的问题非常有用。












